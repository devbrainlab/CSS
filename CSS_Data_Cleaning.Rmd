---
title: "CSS_Data_Import"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = TRUE,
	warning = TRUE
)
```

```{r Load Required Packages, message=FALSE, warning=FALSE, include=FALSE}
## Load required packages ##
packages <-  c("tidyverse",
               "reshape2",
               "nlme", "lme4",
               "data.table", "psych",
               "parallel","lubridate",
               "mgcv", "ggpubr", "broom", "table1", "apaTables", "readxl")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))  
}
lapply(packages, library, character.only = TRUE)


theme_kate <- function () { 
  theme_bw() +
    theme_minimal(base_size = 14, base_family = "Avenir") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          legend.position="none")
}
```

Set root path for Lucy
```{r}
root_path="/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/"
```


Import data files
```{r}
#read in Qualtrics data
qualtrics <- list.files(path="/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/Qualtrics", full.names = TRUE) %>% 
  lapply(read_excel) %>% 
  bind_rows %>%
  select(7,9,27:96, 137, 142, 143)

#Convert to numeric (NOTE: Need to do this to other columns as well, figure out which ones & potentially do this on import)
qualtrics$wave <- as.numeric(qualtrics$wave)
#Replace NA values w/ 1 (no wave specified first week)
qualtrics$wave[is.na(qualtrics$wave)] <- 1


#read in RedCap data
redcap <- read.csv("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/RedCap/Covid19SocialScreens_DATA_2020-11-18_2325.csv") %>%
  dplyr::rename(ResponseId=qualtrics_id)

#Join Qualtrics and Redcap data, sort by ID and wave
all_data <- left_join(qualtrics, redcap, by="ResponseId") %>%
  arrange(record_id, wave)
#Rearrange columns to bring record id and wave to the beginning
all_data <- all_data[,c(76, 75, 1:74, 77:ncol(all_data))]

save(all_data, file="all_data.Rda")


#Read in Network Canvas Data wave by wave, add columns for filename(ID) and wave #
datalist = list()
for (i in 1:10) {
   test <- list.files(path = paste0("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/NetCanvasCSV/Wave", i),
           pattern="*.csv", 
           full.names = T) %>% 
     map_df(function(x) read_csv(x, col_types = cols(.default = "c")) %>%
            mutate(ResponseId=gsub(".csv","",basename(x)))%>%
              mutate(wave=i)
            )
   datalist[[i]] <- test
}
netcanvas <- dplyr::bind_rows(datalist)
save(netcanvas, file="netcanvas.Rda")
```

Load Saved Data
```{r}
#' *Run to load full data * 
load("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/all_data.Rda")
load("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/netcanvas.Rda")
load("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/netcanvas_cleaned.Rda")


#' *Run to load processed data*
load("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/processed_data.Rda")
```

Calculate Summary Stats
```{r}

#calculate mean age of participants that completed 2+ waves

age_calc <- qualtrics %>%
  select("age_years", "age_months", "wave") %>%
  filter(wave==2) %>%
  add_row("age_years" = "18", "age_months"= "5", "wave"= 6)

age_calc$age_years <- as.numeric(age_calc$age_years)
age_calc$age_months <- as.numeric(age_calc$age_months)

age_calc$years_in_months <- age_calc$age_years*12 
age_calc$age_in_months <- age_calc$years_in_months + age_calc$age_months#rowSums(age_calc[2,4])

mean_age <- mean(age_calc$age_in_months)
sd_age <- sd(age_calc$age_in_months)

```

Calculate Sum Scores + Subscores
```{r}

#create copy for testing
data_copy <- data.frame(all_data)

#Recode YAM-5
data_copy <- data_copy %>%
  mutate_at(vars(starts_with("yam")),
  .funs=funs(recode(.,"Never"=0, "Sometimes"=1, "Often"=2, "Always"=3)))  #Need to figure out how to add default
#sum scores for YAM-5
data_copy <- data_copy %>% mutate(yam_total = rowSums(.[grep("yam", names(.))], na.rm = T))  #remove NAs - make sure to account for this

#NOTE: Selective mutism subscale was not included in questions- question numbers have been shifted accordingly (may be different than what is stated online)
#Subscores for YAM-5: sum and divide by number of completed items
#Separation Anxiety:
data_copy <- data_copy %>% mutate(yam_separation = rowSums(.[c("yam_1", "yam_5", "yam_9", "yam_13", "yam_17", "yam_21")], na.rm = T))

#Mutism was excluded from scale
#Selective Mutism: 2,11,20,25    

#Social Anxiety: 3,7,12,16,23,28
data_copy <- data_copy %>% mutate(yam_social = rowSums(.[c("yam_2", "yam_6", "yam_10", "yam_14", "yam_20", "yam_24")], na.rm = T))
#Panic Disorder:4,8,13,17,21,26
data_copy <- data_copy %>% mutate(yam_panic = rowSums(.[c("yam_3", "yam_7", "yam_11", "yam_15", "yam_18", "yam_22")], na.rm = T))
#Generalized Anxiety:5,9,14,18,22,27
data_copy <- data_copy %>% mutate(yam_general = rowSums(.[c("yam_4", "yam_8", "yam_12", "yam_16", "yam_19", "yam_23")], na.rm = T))

# Calculate how many YAM items were left unanswered, exclude if <80%
data_copy <- data_copy %>% mutate(yam_na = rowSums(is.na(.[grep("yam", names(.))]), na.rm = T))
#if >=5 items left blank, exclude

yam_exclusion_indices <- which(data_copy$yam_na >= 5)  #indices of participants excluded for >= 5 NAs
yam_exclusion_ids <- data_copy$ResponseID[yam_exclusion_indices] #ids of excluded participants

#If needed for an analysis, exclude participants
#yam_analysis <- subset(data_copy, (!(ResponseID %in% yam_exclusion_ids)))

#Recode MSPSS
data_copy <- data_copy %>%
  mutate_at(vars(starts_with("mspss")),
  .funs=funs(recode(.,"Very Strongly Disagree"=1, "Strongly Disagree"=2, "Mildly Disagree"=3, "Neutral"=4, "Mildly Agree"=5, "Strongly Agree"=6, "Very Strongly Agree"=7))) 


#sum scores for MSPSS
data_copy <- data_copy %>% mutate(mspss_total = rowSums(.[grep("mspss", names(.))], na.rm = T)/12)

#Subscores for MSPSS
# Significant Other: 1,2,5,10 (sum & divide by 4)
data_copy <- data_copy %>% mutate(mspss_sigother = rowSums(.[c("mspss_1", "mspss_2", "mspss_5", "mspss_10")], na.rm = T)/(4-rowSums(is.na(.[c("mspss_1", "mspss_2", "mspss_5", "mspss_10")]))))
# Family: 3,4,8,11 (sum & divide by 4)
data_copy <- data_copy %>% mutate(mspss_family = rowSums(.[c("mspss_3", "mspss_4", "mspss_8", "mspss_11")], na.rm = T)/(4-rowSums(is.na(.[c("mspss_3", "mspss_4", "mspss_8", "mspss_11")]))))
# Friends: 6,7,9,12 (sum & divide by 4)
data_copy <- data_copy %>% mutate(mspss_friends = rowSums(.[c("mspss_6", "mspss_7", "mspss_9", "mspss_12")], na.rm = T)/(4-rowSums(is.na(.[c("mspss_6", "mspss_7", "mspss_9", "mspss_12")]))))

# Calculate how many MSPSS items were finished, exclude if <80%
data_copy <- data_copy %>% mutate(mspss_na = rowSums(is.na(.[grep("mspss", names(.))]), na.rm = T))
#If >= 3 items left blank, exclude

mspss_exclusion_indices <- which(data_copy$mspss_na >= 3)  #indices of participants excluded for >- 3 NAs
mspss_exclusion_ids <- data_copy$ResponseID[mspss_exclusion_indices] #ids of excluded participants

#If needed for an analysis, exclude participants
#mspss_analysis <- subset(data_copy, (!(ResponseID %in% mspss_exclusion_ids)))
```

Data Viz for YAM & MSPSS
```{r}
#box plot for yam by wave
ggboxplot(data_copy, x = "wave", y = "yam_total", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_separation", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_social", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_panic", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_general", color="wave")


#box plot for mspss by wave
ggboxplot(data_copy, x = "wave", y = "mspss_total", color="wave")
ggboxplot(data_copy, x = "wave", y = "mspss_sigother", color="wave")
ggboxplot(data_copy, x = "wave", y = "mspss_family", color="wave")
ggboxplot(data_copy, x = "wave", y = "mspss_friends", color="wave")


```

Screentime
```{r}
# For each wave, check if screentime is complete, search app_category_this_week_[1-5] for social or Social, find matching time
#screentime_complete==1 & ifelse(grepl("social"|"Social", data_copy$[app_category_this_week[1-5]]), "yes", "no")

#Get social screen use per week

#Convert format to long (category names)
socialmediathisweek<-data_copy %>%
  select(wave, ResponseId,contains("app_category_this_week_")) %>% 
  gather(key = category, value=app,3:7)


#Convert format to long (category time), change values to match categories above
socialmediatimethisweek<-data_copy %>%
  select(wave, ResponseId,contains("app_category_time_this_week_")) %>% 
  gather(key=category,value=socialtime,3:7) %>%
  mutate(category = case_when(
    category=="app_category_time_this_week_1" ~ "app_category_this_week_1",
    category=="app_category_time_this_week_2" ~ "app_category_this_week_2",
    category=="app_category_time_this_week_3" ~ "app_category_this_week_3",
    category=="app_category_time_this_week_4" ~ "app_category_this_week_4",
    category=="app_category_time_this_week_5" ~ "app_category_this_week_5"
  ))

#Join to get time per category, filter out non social networking values
socialuse<-left_join(socialmediathisweek, socialmediatimethisweek,by=c("wave","ResponseId", "category")) %>%
  filter(app=="Social Networking" | app=="social networking") 


#Convert time to numeric value (i.e. 2:04 to 124 minutes)
  socialuse$socialtimemin = as.numeric(unlist(lapply(socialuse$socialtime, function (x) strsplit(x, ":")[[1]][1])))*60 +
  as.numeric(unlist(lapply(socialuse$socialtime, function (x) strsplit(x, ":")[[1]][2])))
  
  
#All Screen Use:
  data_copy$tot_time_min = as.numeric(unlist(lapply(data_copy$tot_time_this_week, function (x) strsplit(x, ":")[[1]][1])))*60 +
  as.numeric(unlist(lapply(data_copy$tot_time_this_week, function (x) strsplit(x, ":")[[1]][2])))
  

# Need to take notes into account? Days included? Last week's data?
```

Data Viz for Screentime
```{r}
#boxplot for social use by wave
ggboxplot(socialuse, x="wave", y="timemin", color="wave")

#box plot for overall use by wave
ggboxplot(data_copy, x="wave", y="tot_time_min", color="wave")


packages <- c("ggplot2", "dplyr", "lavaan", "plyr", "cowplot", "rmarkdown", 
              "readr", "caTools", "bitops")

if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))  
}
library(cowplot)
library(dplyr)
library(readr)


p_social_time <- ggplot(processed_data,aes(x=as.factor(wave),y=socialtimemin, fill = wave))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust = 2)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  ylab('Score')+xlab('Group')+coord_flip()+theme_cowplot()+guides(fill = FALSE)+
  ggtitle('Figure 3: The Basic Raincloud with Colour')

p_social_time

p_tot_time <- ggplot(processed_data,aes(x=as.factor(wave),y=tot_time_min, fill = wave))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust = 2)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  ylab('Score')+xlab('Group')+coord_flip()+theme_cowplot()+guides(fill = FALSE)+
  ggtitle('Figure 3: The Basic Raincloud with Colour')

p_tot_time




#
```

Social Connections
```{r}
#Calculate percentage of similarly named friends for each wave
# Join netcanvas to all_data to get record_ids, select columns that we want to keep

netcanvas_by_record <- inner_join(netcanvas, all_data, by="ResponseId")%>%
  select(record_id, ResponseId, wave.x, name, household_relationship, illness, frequency_communication, give_support, receive_support, communication_methods, age) %>% # ~20 rows less than netcanvas...could be netcanvas ids missing from all_data
   filter(is.na(household_relationship)|household_relationship=="friend")

#Make new dataframe for counts
netcanvas_cleaned = test_set[FALSE,] #from testing below
netcanvas_cleaned <- netcanvas_cleaned  %>% 
  add_column(unique_friends = NA, .after = "names") %>% 
  add_column(common_friends = NA, .after = "unique_friends") %>%
  dplyr::rename(record_id=id)
netcanvas_cleaned$record_id <- as.integer(netcanvas_cleaned$record_id)


#For each kid, for each wave, split data by wave, iterate through waves, find intersect & union of friends in wave and wave+1, record info in new row of datatable

for (kid in unique(netcanvas_by_record$record_id)) {
  splitted <- split(netcanvas_by_record$name[which(netcanvas_by_record$record_id==kid)],netcanvas_by_record$wave.x[which(netcanvas_by_record$record_id==kid)])
  for(wave_num in 0:9){
     netcanvas_cleaned <- netcanvas_cleaned %>% add_row(record_id=kid, wave=wave_num+1, common_friends=length(intersect(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))), unique_friends=length(union(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))))
     #print(length(union(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))))
  }
}
#note: at wave, friends in common is 0, unique friends is number of friends at that wave
#note: when joining this back in, make sure we drop waves where the participant has no friends listed

#calculate proportion of friends stable between waves (common friends/unique friends)
netcanvas_cleaned <- netcanvas_cleaned %>%
transform(prop_friend_stability = common_friends / unique_friends)

save(netcanvas_cleaned, file="netcanvas_cleaned.Rda")

processed_data <- left_join(data_copy, netcanvas_cleaned)
processed_data <- left_join(processed_data, socialuse)
processed_data <- processed_data %>%
  select(-c(names, category, app))

save(processed_data, file="processed_data.Rda")
```

Social Connections Plots
```{r}
ggboxplot(processed_data, x="wave", y="prop_friend_stability", color="wave")

```

Intersect & For Loop Testing
```{r}
#intersect of id x wave


  #output should be num of names in common between 2 waves, maybe number unique names
  #mutate(common = intersect(group1, group2))%>%
  #mutate(unique = unique(group1, group2))
  #find ratio of names in common to total names
  #possibly use group_map 
  #lag()
  
  #where(wave = X)
  
  grouped<- netcanvas %>%
    group_by(ResponseId, wave.x) %>%
 filter(is.na(household_relationship)|household_relationship=="friend") %>%
    lapply(X=1:10,
        FUN = function(X){
          wave1=X
          wave2=X+1
          output<-group %>%
          intersect(wave1,wave2)
         }
      )
  
  net_list = split(netcanvas, netcanvas$ResponseId)
  
  data[data$participant %in% c(8, 10),]
  


#arrange by wave, group by id, intersect on group and lag(group)

#calculate percentage of similarly named friends across waves: percentage of what? total unique friends in both waves? friends in later waves? 

#for i in 1:length of group a(participant x wavea):
  #for z in 1:length of group b(participant x waveb)
    #if i==z
      #return true or +1

#find set union - need to figure out how to pass groups and get return value
#intersect(x,y)
a<- c('person1', 'person2', 'person3')
b<- c('person1', 'person4', 'person3')
intersect(a,b)
length(intersect(a,b))



#Test Data

id <- c("a", "a", "a", "b","b","b","b", "c", "c", "c", "d", "d", "d", "d", "a", "a","b","b","c","c","d","d")
wave<- c(1,1,2,1,1,2,2,1,2,2,1,1,2,1,3,3,3,3,3,3,3,3)
names<-c("amy", "arnold", "amy", "bob", "becca", "bob", "becca", "carl", "carly", "carl", "dan", "dani", "danny", "carly", "arnold", "amy", "becca", "bobby", "carly", "carl", "don", "dave")
test_set<- data.frame(id,wave,names) %>%
    group_by(id) %>%
  
  x<-c(1,2)
  loop_test<- #test_set%>%
  for(i in c(1,2)){
    function(i) print(intersect(test_set$names[which(wave==i)], test_set$names[which(wave==i+1)]))
  }
    
  loop_test<- test_set%>%
  lapply(x=1,
    FUN=function(x) intersect(test_set$names[which(wave==x)], test_set$names[which(wave==x+1)])
    )
  
  

  loop_test2<- test_set %>% group_map(intersect, test_set$names[which(wave==1)], test_set$names[which(wave==2)])
  
Reduce(intersect, split(test_set$names[which(wave==1)], test_set$wave[which(wave==1)]))
  intersect(split(test_set$names, test_set$wave), test_set$id)
  
fakefuck <- test_set[which(test_set$wave==1),]# %>% select(-id)

for (kid in c('a','b','c','d') ) {
  print(Reduce(intersect, split(test_set$names[which(id==kid)], test_set$wave[which(id==kid)])))
}

for (kid in unique(id)) {   #,'b','c','d'
  splitted <- split(test_set$names[which(id==kid)], test_set$wave[which(id==kid)])
  for(wave in 1:2){
     print(length(intersect(unlist(splitted[wave]), unlist(splitted[wave+1]))))
  }
}


#This works! Wave 1 means 1 to 2, 2 means 2, 3, 3 is blank 
final = test_set[FALSE,]
final <- final  %>% add_column(friends = NA, .after = "names")
for (kid in unique(id)) {   #,'b','c','d'
  splitted <- split(test_set$names[which(id==kid)], test_set$wave[which(id==kid)])
  for(wave in 1:3){
    #friend_col[length(friend_col)+1] <- length(intersect(unlist(splitted[wave]), unlist(splitted[wave+1])))
    #final$friends[which(id==kid&wave==wave)] = length(intersect(unlist(splitted[wave]), unlist(splitted[wave+1])))
    #mutate(final$friends[which(id==kid&wave==wave)] = length(intersect(unlist(splitted[wave]), unlist(splitted[wave+1]))))
    #print(final$friends[which(id==kid&wave==wave)])
     final <- final%>% add_row(id=kid, wave=wave, friends=length(intersect(unlist(splitted[wave]), unlist(splitted[wave+1]))))
  }
}


    lapply(X=1:10,
        FUN = function(X){
          wave1=X
          wave2=X+1
          output<-group %>%
          intersect(wave1,wave2)
         }
      )

    # This works! 1 is zero, 2 is for wave 1->2, 3 is for 2->3
final = test_set[FALSE,]
final <- final  %>% add_column(common_friends = NA, .after = "names")
final <- final  %>% add_column(unique_friends = NA, .after = "names")

for (kid in unique(id)) {   #,'b','c','d'
  splitted <- split(test_set$names[which(id==kid)], test_set$wave[which(id==kid)])
  for(wave_num in 0:2){
     final <- final%>% add_row(id=kid, wave=wave_num+1, common_friends=length(intersect(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))))
  }
}
#add column for common_friends/unique friends



final = test_set[FALSE,]
final <- final  %>% add_column(common_friends = NA, .after = "names")
final <- final  %>% add_column(unique_friends = NA, .after = "names")

for (kid in unique(id)) {   #,'b','c','d'
  splitted <- split(test_set$names[which(id==kid)], test_set$wave[which(id==kid)])
  for(wave_num in 0:2){
     final <- final%>% add_row(id=kid, wave=wave_num+1, common_friends=length(intersect(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))), unique_friends =length(union(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))))
     print(length(union(unlist(splitted[wave_num]), unlist(splitted[wave_num+1]))))
  }
}
final <- final%>%
transform(prop_friend_stability = common_friends / unique_friends)







final_apply = test_set[FALSE,]
final_apply <- final_apply  %>% add_column(friends = NA, .after = "names")
for(kid in unique(id)){
  splitted <- split(test_set$names[which(id==kid)], test_set$wave[which(id==kid)])
  lapply(x=1:3, FUN=function(x)
           final_apply <- final_apply%>% add_row(id=kid, wave=x, friends=length(intersect(unlist(splitted[x]), unlist(splitted[x+1])))
         ))
}
               

```

Start Building Models
```{r}

#


```

