---
title: "CSS_Data_Import"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = TRUE,
	warning = TRUE
)
```

```{r Load Required Packages, message=FALSE, warning=FALSE, include=FALSE}
## Load required packages ##
packages <-  c("tidyverse",
               "reshape2",
               "nlme", "lme4",
               "data.table", "psych",
               "parallel","lubridate",
               "mgcv", "ggpubr", "broom", "table1", "apaTables", "readxl")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))  
}
lapply(packages, library, character.only = TRUE)


theme_kate <- function () { 
  theme_bw() +
    theme_minimal(base_size = 14, base_family = "Avenir") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          legend.position="none")
}
```

Set root path for Lucy
```{r}
root_path="/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/"
```


Import data files
```{r}
#read in Qualtrics data
qualtrics <- list.files(path="/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/Qualtrics", full.names = TRUE) %>% 
  lapply(read_excel) %>% 
  bind_rows %>%
  select(7,9,27:96, 137, 142, 143)

#Convert to numeric (NOTE: Need to do this to other columns as well, figure out which ones & potentially do this on import)
qualtrics$wave <- as.numeric(qualtrics$wave)
#Replace NA values w/ 1 (no wave specified first week)
qualtrics$wave[is.na(qualtrics$wave)] <- 1


#read in RedCap data
redcap <- read.csv("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/RedCap/Covid19SocialScreens_DATA_2020-09-04_2056.csv") %>%
  rename(ResponseId=qualtrics_id)

#Join Qualtrics and Redcap data, sort by ID and wave
all_data <- left_join(qualtrics, redcap, by="ResponseId") %>%
  arrange(record_id, wave)
#Rearrange columns to bring record id and wave to the beginning
all_data <- all_data[,c(76, 75, 1:74, 77:ncol(all_data))]

save(all_data, file="all_data.RDA")


#Read in Network Canvas Data wave by wave, add columns for filename(ID) and wave #
datalist = list()
for (i in 1:10) {
   test <- list.files(path = paste0("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/NetCanvasCSV/Wave", i),
           pattern="*.csv", 
           full.names = T) %>% 
     map_df(function(x) read_csv(x, col_types = cols(.default = "c")) %>%
            mutate(ResponseId=gsub(".csv","",basename(x)))%>%
              mutate(wave=i)
            )
   datalist[[i]] <- test
}
netcanvas <- dplyr::bind_rows(datalist)
save(netcanvas, file="netcanvas.Rda")
```

Load Saved Data
```{r}
#' *Run to load full data * 
load("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/all_data.RDA")
load("/Volumes/devbrainlab/Covid19SocialScreens/CSS_Data/netcanvas.RDA")
```

Calculate Summary Stats
```{r}

#calculate mean age of participants that completed 2+ waves

age_calc <- qualtrics %>%
  select("age_years", "age_months", "wave") %>%
  filter(wave==2) %>%
  add_row("age_years" = "18", "age_months"= "5", "wave"= 6)

age_calc$age_years <- as.numeric(age_calc$age_years)
age_calc$age_months <- as.numeric(age_calc$age_months)

age_calc$years_in_months <- age_calc$age_years*12 
age_calc$age_in_months <- age_calc$years_in_months + age_calc$age_months#rowSums(age_calc[2,4])

mean_age <- mean(age_calc$age_in_months)
sd_age <- sd(age_calc$age_in_months)

```

Calculate Sum Scores + Subscores
```{r}

#create copy for testing
data_copy <- data.frame(all_data)

#Recode YAM-5
data_copy <- data_copy %>%
  mutate_at(vars(starts_with("yam")),
  .funs=funs(recode(.,"Never"=0, "Sometimes"=1, "Often"=2, "Always"=3)))  #Need to figure out how to add default
#sum scores for YAM-5
data_copy <- data_copy %>% mutate(yam_total = rowSums(.[grep("yam", names(.))], na.rm = T))  #remove NAs - make sure to account for this

#NOTE: Selective mutism subscale was not included in questions- question numbers have been shifted accordingly (may be different than what is stated online)
#Subscores for YAM-5: sum and divide by number of completed items
#Separation Anxiety:
data_copy <- data_copy %>% mutate(yam_separation = rowSums(.[c("yam_1", "yam_5", "yam_9", "yam_13", "yam_17", "yam_21")], na.rm = T))

#Mutism was excluded from scale
#Selective Mutism: 2,11,20,25    

#Social Anxiety: 3,7,12,16,23,28
data_copy <- data_copy %>% mutate(yam_social = rowSums(.[c("yam_2", "yam_6", "yam_10", "yam_14", "yam_20", "yam_24")], na.rm = T))
#Panic Disorder:4,8,13,17,21,26
data_copy <- data_copy %>% mutate(yam_panic = rowSums(.[c("yam_3", "yam_7", "yam_11", "yam_15", "yam_18", "yam_22")], na.rm = T))
#Generalized Anxiety:5,9,14,18,22,27
data_copy <- data_copy %>% mutate(yam_general = rowSums(.[c("yam_4", "yam_8", "yam_12", "yam_16", "yam_19", "yam_23")], na.rm = T))

# Calculate how many YAM items were left unanswered, exclude if <80%
data_copy <- data_copy %>% mutate(yam_na = rowSums(is.na(.[grep("yam", names(.))]), na.rm = T))
#if >=5 items left blank, exclude

#Recode MSPSS
data_copy <- data_copy %>%
  mutate_at(vars(starts_with("mspss")),
  .funs=funs(recode(.,"Very Strongly Disagree"=1, "Strongly Disagree"=2, "Mildly Disagree"=3, "Neutral"=4, "Mildly Agree"=5, "Strongly Agree"=6, "Very Strongly Agree"=7))) 


#sum scores for MSPSS
data_copy <- data_copy %>% mutate(mspss_total = rowSums(.[grep("mspss", names(.))], na.rm = T)/12)

#Subscores for MSPSS
# Significant Other: 1,2,5,10 (sum & divide by 4)
data_copy <- data_copy %>% mutate(mspss_sigother = rowSums(.[c("mspss_1", "mspss_2", "mspss_5", "mspss_10")], na.rm = T)/4)
# Family: 3,4,8,11 (sum & divide by 4)
data_copy <- data_copy %>% mutate(mspss_family = rowSums(.[c("mspss_3", "mspss_4", "mspss_8", "mspss_11")], na.rm = T)/4)
# Friends: 6,7,9,12 (sum & divide by 4)
data_copy <- data_copy %>% mutate(mspss_friends = rowSums(.[c("mspss_6", "mspss_7", "mspss_9", "mspss_12")], na.rm = T)/4)

# Calculate how many MSPSS items were finished, exclude if <80%
data_copy <- data_copy %>% mutate(mspss_na = rowSums(is.na(.[grep("mspss", names(.))]), na.rm = T))
#If >= 3 items left blank, exclude


#still need to divide by number of completed items

```

Data Viz for YAM & MSPSS
```{r}
#box plot for yam by wave
ggboxplot(data_copy, x = "wave", y = "yam_total", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_separation", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_social", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_spanic", color="wave")
ggboxplot(data_copy, x = "wave", y = "yam_general", color="wave")


#box plot for mspss by wave
ggboxplot(data_copy, x = "wave", y = "mspss_total", color="wave")
ggboxplot(data_copy, x = "wave", y = "mspss_sigother", color="wave")
ggboxplot(data_copy, x = "wave", y = "mspss_family", color="wave")
ggboxplot(data_copy, x = "wave", y = "mspss_friends", color="wave")


```

Screentime
```{r}
# For each wave, check if screentime is complete, search app_category_this_week_[1-5] for social or Social, find matching time
#screentime_complete==1 & ifelse(grepl("social"|"Social", data_copy$[app_category_this_week[1-5]]), "yes", "no")

#Get social screen use per week

#Convert format to long (category names)
socialmediathisweek<-data_copy %>%
  select(wave, ResponseId,contains("app_category_this_week_")) %>% 
  gather(key = category, value=app,3:7)


#Convert format to long (category time), change values to match categories above
socialmediatimethisweek<-data_copy %>%
  select(wave, ResponseId,contains("app_category_time_this_week_")) %>% 
  gather(key=category,value=socialtime,3:7) %>%
  mutate(category = case_when(
    category=="app_category_time_this_week_1" ~ "app_category_this_week_1",
    category=="app_category_time_this_week_2" ~ "app_category_this_week_2",
    category=="app_category_time_this_week_3" ~ "app_category_this_week_3",
    category=="app_category_time_this_week_4" ~ "app_category_this_week_4",
    category=="app_category_time_this_week_5" ~ "app_category_this_week_5"
  ))

#Join to get time per category, filter out non social networking values
socialuse<-left_join(socialmediathisweek, socialmediatimethisweek,by=c("wave","ResponseId", "category")) %>%
  filter(app=="Social Networking" | app=="social networking") 


#Convert time to numeric value (i.e. 2:04 to 124 minutes)
  socialuse$timemin = as.numeric(unlist(lapply(socialuse$socialtime, function (x) strsplit(x, ":")[[1]][1])))*60 +
  as.numeric(unlist(lapply(socialuse$socialtime, function (x) strsplit(x, ":")[[1]][2])))
  
  
#All Screen Use:
  data_copy$tot_time_min = as.numeric(unlist(lapply(data_copy$tot_time_this_week, function (x) strsplit(x, ":")[[1]][1])))*60 +
  as.numeric(unlist(lapply(data_copy$tot_time_this_week, function (x) strsplit(x, ":")[[1]][2])))
  

# Need to take notes into account? Days included? Last week's data?
```

Data Viz for Screentime
```{r}
#boxplot for social use by wave
ggboxplot(socialuse, x="wave", y="timemin", color="wave")

#box plot for overall use by wave
ggboxplot(data_copy, x="wave", y="tot_time_min", color="wave")


raincloud_theme = theme(
text = element_text(size = 10),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
axis.text = element_text(size = 14),
axis.text.x = element_text(angle = 45, vjust = 0.5),
legend.title=element_text(size=16),
legend.text=element_text(size=16),
legend.position = "right",
plot.title = element_text(lineheight=.8, face="bold", size = 16),
panel.border = element_blank(),
panel.grid.minor = element_blank(),
panel.grid.major = element_blank(),
axis.line.x = element_line(colour = 'black', size=0.5, linetype='solid'),
axis.line.y = element_line(colour = 'black', size=0.5, linetype='solid'))

g <- ggplot(data = socialuse, aes(y = timemin, x = wave, fill = wave)) +
geom_flat_violin(position = position_nudge(x = .2, y = 0), alpha = .8) +
geom_point(aes(y = timemin, color = wave), position = position_jitter(width = .15), size = .5, alpha = 0.8) +
geom_boxplot(width = .1, guides = FALSE, outlier.shape = NA, alpha = 0.5) +
expand_limits(x = 5.25) +
guides(fill = FALSE) +
guides(color = FALSE) +
scale_color_brewer(palette = "Spectral") +
scale_fill_brewer(palette = "Spectral") +
# coord_flip() +
theme_bw() +
raincloud_theme

g

```

Social Connections
```{r}
#Calculate percentage of similarly named friends for each wave
# sort by participant, compare names to previous wave

join_test <- inner_join(netcanvas, all_data, by="ResponseId")%>%
  select(record_id, ResponseId, wave.x, name, household_relationship, illness, frequency_communication, give_support, receive_support, communication_methods, age) %>% # ~20 rows less than netcanvas...could be netcanvas ids missing from all_data
    group_by_at(vars(record_id, wave.x)) %>%
    filter(is.na(household_relationship)|household_relationship=="friend") %>%
    lapply(X=1:10,
      FUN = function(X){
        wave1=X
        wave2=X+1
        
    output<-group %>%
      intersect(wave1,wave2) #wave 1 = name from group
      }
      )



  #output should be num of names in common between 2 waves, maybe number unique names
  #mutate(common = intersect(group1, group2))%>%
  #mutate(unique = unique(group1, group2))
  #find ratio of names in common to total names
  #possibly use group_map 
  #lag()
  
  #where(wave = X)
  
  grouped<- netcanvas %>%
    group_by(ResponseId, wave) %>%
 filter(is.na(household_relationship)|household_relationship=="friend") %>%
    lapply(X=1:10,
               FUN = function(X){
                 wave1=X
        wave2=X+1
    output<-group %>%
      intersect(wave1,wave2)
      }
      )
  
  net_list = split(netcanvas, netcanvas$ResponseId)
  
  data[data$participant %in% c(8, 10),]

#arrange by wave, group by id, intersect on group and lag(group)

#calculate percentage of similarly named friends across waves: percentage of what? total unique friends in both waves? friends in later waves? 

#for i in 1:length of group a(participant x wavea):
  #for z in 1:length of group b(participant x waveb)
    #if i==z
      #return true or +1

#find set union - need to figure out how to pass groups and get return value
#intersect(x,y)
a<- c('person1', 'person2', 'person3')
b<- c('person1', 'person4', 'person3')
intersect(a,b)
length(intersect(a,b))


```

Start Building Models
```{r}

#


```

